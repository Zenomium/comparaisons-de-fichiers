#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "mtrack_03.h"

#define INITIAL_CAPACITY 10

typedef struct {
    void *address;   
    size_t size;     
    bool is_free;    
} data_cell;

typedef struct {
    data_cell *cells;   // tableau dynamique
    size_t count;     
    size_t capacity;       
    unsigned int malloc_calls; 
    unsigned int free_calls;  
    unsigned int free_failures; 
    size_t total_allocated;    
    size_t total_freed;        
} _Environnement;

_Environnement env = {NULL, 0, 0, 0, 0, 0, 0, 0};
bool _end_flag = false;

void _init_environment() {
    env.capacity = INITIAL_CAPACITY;
    env.cells = malloc(env.capacity * sizeof(data_cell));
    if (!env.cells) {
        perror("L'initialisation de l'environnement a échoué.\n");
        exit(1);
    }
}

void _show_result() {
    printf("-----------------------\n");
    printf("BILAN FINAL\n");
    printf("total mémoire allouée : %zu octets\n", env.total_allocated);
    printf("total mémoire libérée : %zu octets\n", env.total_freed);
    printf("ratio                 : %.2f%%\n", env.total_allocated ? 
           ((double)env.total_freed / env.total_allocated) * 100 : 0);
    printf("<malloc>              : %u appels\n", env.malloc_calls);
    printf("<free>                : %u appel(s) correct(s)\n", env.free_calls);
    printf("                      : %u appel(s) incorrect(s)\n", env.free_failures);
    printf("-----------------------\n");
}

void _ending() {
    _show_result();
    // Libération de la mémoire
    for (size_t i = 0; i < env.count; i++) {
        if (env.cells[i].is_free) {
            free(env.cells[i].address);
        }
    }
    free(env.cells);
}

void* _my_malloc(size_t size) {
    if (!_end_flag) {
        _end_flag = true; 
        _init_environment();
        atexit(_ending); 
    }

    void *ptr = malloc(size);
    if (ptr) {
        if (env.count >= env.capacity) {
            perror("L'environnement a saturé.\n");
            exit(1);
        }

        env.cells[env.count].address = ptr;
        env.cells[env.count].size = size;
        env.cells[env.count].is_free = true;
        env.total_allocated += size;
        env.malloc_calls++;
        printf("(0%d) malloc(%zu)->%p\n", env.malloc_calls, size, ptr);
        env.count++;
    }
    return ptr;
}

void _my_free(void *ptr) {
    if (!_end_flag) {
        _end_flag = true; 
        _init_environment();
        atexit(_ending); 
    }

    if (ptr == NULL) {
        return;
    }

    for (size_t i = 0; i < env.count; i++) {
        if (env.cells[i].address == ptr) {
            if (!env.cells[i].is_free) {
                printf("(0%d) free(%p) - ERREUR : adresse déjà libérée -> ignoré\n", env.free_calls + 1, ptr);
                env.free_failures++;
                return;
            }
            env.cells[i].is_free = false;
            env.total_freed += env.cells[i].size;
            env.free_calls++;
            free(ptr);
            printf("(0%d) free(%p)\n", env.free_calls, ptr);
            return;
        }
    }
    printf("(0%d) free(%p) - ERREUR : adresse illégale -> ignoré\n", env.free_calls + 1, ptr);
    env.free_failures++;
}

